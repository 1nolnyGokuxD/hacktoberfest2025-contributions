[
  {
    "id": "intermediate-1",
    "question": "What is closure in JavaScript?",
    "answer": "A closure is a function that has access to variables in its outer (enclosing) scope even after the outer function has finished executing. Closures are created every time a function is created.\n\n**Example:**\n```javascript\nfunction outerFunction(x) {\n  // Outer function's variable\n  let outerVariable = x;\n  \n  // Inner function (closure)\n  function innerFunction(y) {\n    console.log(outerVariable + y); // Can access outerVariable\n  }\n  \n  return innerFunction;\n}\n\nconst myClosure = outerFunction(10);\nmyClosure(5); // 15 (can still access outerVariable)\n```\n\n**Practical Example - Counter:**\n```javascript\nfunction createCounter() {\n  let count = 0;\n  \n  return function() {\n    count++;\n    return count;\n  };\n}\n\nconst counter = createCounter();\nconsole.log(counter()); // 1\nconsole.log(counter()); // 2\nconsole.log(counter()); // 3\n```\n\n**Benefits:**\n- Data privacy/encapsulation\n- Function factories\n- Callbacks and event handlers\n- Module pattern implementation"
  },
  {
    "id": "intermediate-2",
    "question": "Explain 'this' keyword in JavaScript",
    "answer": "The 'this' keyword refers to the object that is currently executing the function. Its value depends on how the function is called.\n\n**1. Global Context:**\n```javascript\nconsole.log(this); // Window object (in browser) or global object (in Node.js)\n```\n\n**2. Object Method:**\n```javascript\nconst person = {\n  name: 'John',\n  greet() {\n    console.log(this.name); // 'John' (this refers to person object)\n  }\n};\nperson.greet();\n```\n\n**3. Regular Function:**\n```javascript\nfunction regularFunction() {\n  console.log(this); // Window object (non-strict mode) or undefined (strict mode)\n}\n```\n\n**4. Arrow Function:**\n```javascript\nconst obj = {\n  name: 'John',\n  regularMethod() {\n    console.log(this.name); // 'John'\n    \n    const arrowFunction = () => {\n      console.log(this.name); // 'John' (inherits from parent scope)\n    };\n    arrowFunction();\n  }\n};\n```\n\n**5. Constructor Function:**\n```javascript\nfunction Person(name) {\n  this.name = name; // 'this' refers to the new instance\n}\nconst john = new Person('John');\n```\n\n**6. Explicit Binding:**\n```javascript\nfunction greet() {\n  console.log(this.name);\n}\n\nconst person = { name: 'John' };\ngreet.call(person);   // 'John'\ngreet.apply(person);  // 'John'\nconst boundGreet = greet.bind(person);\nboundGreet(); // 'John'\n```"
  },
  {
    "id": "intermediate-3",
    "question": "What are Promises in JavaScript?",
    "answer": "Promises are objects that represent the eventual completion or failure of an asynchronous operation. They provide a cleaner alternative to callbacks for handling asynchronous code.\n\n**Promise States:**\n1. **Pending**: Initial state, neither fulfilled nor rejected\n2. **Fulfilled**: Operation completed successfully\n3. **Rejected**: Operation failed\n\n**Creating a Promise:**\n```javascript\nconst myPromise = new Promise((resolve, reject) => {\n  const success = true;\n  \n  setTimeout(() => {\n    if (success) {\n      resolve('Operation successful!');\n    } else {\n      reject('Operation failed!');\n    }\n  }, 1000);\n});\n```\n\n**Using Promises:**\n```javascript\nmyPromise\n  .then(result => {\n    console.log(result); // 'Operation successful!'\n    return 'Next step';\n  })\n  .then(nextResult => {\n    console.log(nextResult); // 'Next step'\n  })\n  .catch(error => {\n    console.error(error);\n  })\n  .finally(() => {\n    console.log('Cleanup code');\n  });\n```\n\n**Promise Methods:**\n```javascript\n// Promise.all - waits for all promises to resolve\nPromise.all([promise1, promise2, promise3])\n  .then(results => console.log(results));\n\n// Promise.race - resolves with first completed promise\nPromise.race([promise1, promise2, promise3])\n  .then(result => console.log(result));\n\n// Promise.resolve - creates resolved promise\nconst resolvedPromise = Promise.resolve('Immediate value');\n\n// Promise.reject - creates rejected promise\nconst rejectedPromise = Promise.reject('Error message');\n```"
  },
  {
    "id": "intermediate-4",
    "question": "What are async/await in JavaScript?",
    "answer": "Async/await is syntactic sugar built on top of Promises that makes asynchronous code look and behave more like synchronous code.\n\n**async function:**\n```javascript\nasync function fetchData() {\n  return 'Hello, World!'; // Automatically wrapped in Promise.resolve()\n}\n\n// Equivalent to:\nfunction fetchData() {\n  return Promise.resolve('Hello, World!');\n}\n```\n\n**await keyword:**\n```javascript\nasync function getData() {\n  try {\n    const response = await fetch('https://api.example.com/data');\n    const data = await response.json();\n    console.log(data);\n    return data;\n  } catch (error) {\n    console.error('Error:', error);\n    throw error;\n  }\n}\n```\n\n**Comparison with Promises:**\n```javascript\n// Using Promises\nfunction fetchUserData() {\n  return fetch('/api/user')\n    .then(response => response.json())\n    .then(user => {\n      return fetch(`/api/posts/${user.id}`);\n    })\n    .then(response => response.json())\n    .then(posts => {\n      console.log(posts);\n      return posts;\n    })\n    .catch(error => {\n      console.error('Error:', error);\n    });\n}\n\n// Using async/await\nasync function fetchUserData() {\n  try {\n    const userResponse = await fetch('/api/user');\n    const user = await userResponse.json();\n    \n    const postsResponse = await fetch(`/api/posts/${user.id}`);\n    const posts = await postsResponse.json();\n    \n    console.log(posts);\n    return posts;\n  } catch (error) {\n    console.error('Error:', error);\n  }\n}\n```\n\n**Parallel Execution:**\n```javascript\n// Sequential (slower)\nasync function sequential() {\n  const result1 = await operation1();\n  const result2 = await operation2();\n  return [result1, result2];\n}\n\n// Parallel (faster)\nasync function parallel() {\n  const [result1, result2] = await Promise.all([\n    operation1(),\n    operation2()\n  ]);\n  return [result1, result2];\n}\n```"
  },
  {
    "id": "intermediate-5",
    "question": "What is the Event Loop in JavaScript?",
    "answer": "The Event Loop is JavaScript's mechanism for handling asynchronous operations in a single-threaded environment. It manages the execution of code, handling events, and executing queued sub-tasks.\n\n**Components:**\n1. **Call Stack**: Where function calls are stacked\n2. **Web APIs**: Browser-provided APIs (setTimeout, DOM events, etc.)\n3. **Callback Queue**: Where callback functions wait\n4. **Event Loop**: Monitors call stack and callback queue\n\n**How it works:**\n```javascript\nconsole.log('Start'); // 1. Added to call stack, executed immediately\n\nsetTimeout(() => {\n  console.log('Timeout'); // 4. Executed after call stack is empty\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise'); // 3. Executed before setTimeout (higher priority)\n});\n\nconsole.log('End'); // 2. Added to call stack, executed immediately\n\n// Output: Start, End, Promise, Timeout\n```\n\n**Microtask Queue vs Macrotask Queue:**\n```javascript\n// Macrotasks: setTimeout, setInterval, I/O operations\n// Microtasks: Promise.then, queueMicrotask, MutationObserver\n\nconsole.log('1');\n\nsetTimeout(() => console.log('2'), 0); // Macrotask\n\nPromise.resolve().then(() => console.log('3')); // Microtask\n\nqueueMicrotask(() => console.log('4')); // Microtask\n\nconsole.log('5');\n\n// Output: 1, 5, 3, 4, 2\n// Microtasks have higher priority than macrotasks\n```\n\n**Visual Representation:**\n```\n┌─────────────────┐\n│    Call Stack   │\n└─────────────────┘\n         │\n         ▼\n┌─────────────────┐    ┌─────────────────┐\n│   Web APIs      │───▶│ Callback Queue  │\n│ (setTimeout,    │    │ (Macrotasks)    │\n│  DOM events)    │    └─────────────────┘\n└─────────────────┘             │\n                                 │\n         ┌─────────────────┐     │\n         │ Microtask Queue │◄────┘\n         │ (Promise.then)  │\n         └─────────────────┘\n                  │\n                  ▼\n         ┌─────────────────┐\n         │   Event Loop    │\n         └─────────────────┘\n```"
  },
  {
    "id": "intermediate-6",
    "question": "What are JavaScript prototypes and prototype chain?",
    "answer": "Prototypes are the mechanism by which JavaScript objects inherit features from one another. Every object has a private property that holds a link to another object called its prototype.\n\n**Understanding Prototypes:**\n```javascript\n// Constructor function\nfunction Person(name) {\n  this.name = name;\n}\n\n// Adding method to prototype\nPerson.prototype.greet = function() {\n  return `Hello, I'm ${this.name}`;\n};\n\n// Creating instances\nconst john = new Person('John');\nconst jane = new Person('Jane');\n\nconsole.log(john.greet()); // \"Hello, I'm John\"\nconsole.log(jane.greet()); // \"Hello, I'm Jane\"\n\n// Both instances share the same method\nconsole.log(john.greet === jane.greet); // true\n```\n\n**Prototype Chain:**\n```javascript\n// Every object has __proto__ property pointing to its prototype\nconsole.log(john.__proto__ === Person.prototype); // true\nconsole.log(Person.prototype.__proto__ === Object.prototype); // true\nconsole.log(Object.prototype.__proto__ === null); // true\n\n// Property lookup follows the prototype chain\nconst obj = {\n  a: 1\n};\n\nconst child = Object.create(obj);\nchild.b = 2;\n\nconsole.log(child.a); // 1 (found in prototype)\nconsole.log(child.b); // 2 (own property)\nconsole.log(child.c); // undefined (not found in chain)\n```\n\n**Modern Class Syntax (ES6):**\n```javascript\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  speak() {\n    return `${this.name} makes a sound`;\n  }\n}\n\nclass Dog extends Animal {\n  constructor(name, breed) {\n    super(name);\n    this.breed = breed;\n  }\n  \n  speak() {\n    return `${this.name} barks`;\n  }\n}\n\nconst dog = new Dog('Buddy', 'Golden Retriever');\nconsole.log(dog.speak()); // \"Buddy barks\"\n\n// Under the hood, still uses prototypes\nconsole.log(dog.__proto__ === Dog.prototype); // true\nconsole.log(Dog.prototype.__proto__ === Animal.prototype); // true\n```\n\n**Prototype Methods:**\n```javascript\n// Object.create() - creates object with specified prototype\nconst parent = { x: 1, y: 2 };\nconst child = Object.create(parent);\nchild.z = 3;\n\n// hasOwnProperty() - checks if property is own (not inherited)\nconsole.log(child.hasOwnProperty('z')); // true\nconsole.log(child.hasOwnProperty('x')); // false\n\n// Object.getPrototypeOf() - gets prototype of object\nconsole.log(Object.getPrototypeOf(child) === parent); // true\n```"
  },
  {
    "id": "intermediate-7",
    "question": "What are JavaScript modules (ES6 modules)?",
    "answer": "ES6 modules provide a way to organize and structure code by allowing you to export and import functionality between files.\n\n**Named Exports:**\n```javascript\n// math.js\nexport const PI = 3.14159;\nexport const E = 2.71828;\n\nexport function add(a, b) {\n  return a + b;\n}\n\nexport function multiply(a, b) {\n  return a * b;\n}\n\n// Or export all at once\nconst subtract = (a, b) => a - b;\nconst divide = (a, b) => a / b;\n\nexport { subtract, divide };\n```\n\n**Default Exports:**\n```javascript\n// calculator.js\nclass Calculator {\n  add(a, b) {\n    return a + b;\n  }\n  \n  subtract(a, b) {\n    return a - b;\n  }\n}\n\nexport default Calculator;\n\n// Or directly\nexport default class Calculator {\n  // class body\n}\n\n// Or for functions\nexport default function greet(name) {\n  return `Hello, ${name}!`;\n}\n```\n\n**Importing:**\n```javascript\n// Named imports\nimport { PI, add, multiply } from './math.js';\nimport { subtract as sub, divide } from './math.js'; // Renaming\n\n// Import all\nimport * as MathUtils from './math.js';\nconsole.log(MathUtils.PI);\nconsole.log(MathUtils.add(2, 3));\n\n// Default imports\nimport Calculator from './calculator.js';\nimport MyCalculator from './calculator.js'; // Can use any name\n\n// Mixed imports\nimport Calculator, { PI, add } from './combined.js';\n\n// Dynamic imports (ES2020)\nasync function loadModule() {\n  const { add } = await import('./math.js');\n  console.log(add(2, 3));\n}\n```\n\n**Re-exports:**\n```javascript\n// index.js - barrel export\nexport { PI, add, multiply } from './math.js';\nexport { default as Calculator } from './calculator.js';\nexport * from './utilities.js';\n\n// Usage\nimport { PI, Calculator, add } from './index.js';\n```\n\n**Module Benefits:**\n- Code organization and maintainability\n- Namespace management\n- Dependency management\n- Tree shaking (dead code elimination)\n- Static analysis and optimization\n\n**CommonJS vs ES6 Modules:**\n```javascript\n// CommonJS (Node.js)\nconst fs = require('fs');\nmodule.exports = { myFunction };\n\n// ES6 Modules\nimport fs from 'fs';\nexport { myFunction };\n```"
  },
  {
    "id": "intermediate-8",
    "question": "Explain array methods: map, filter, reduce, forEach",
    "answer": "These are higher-order functions that operate on arrays and are fundamental to functional programming in JavaScript.\n\n**1. forEach() - Executes function for each element:**\n```javascript\nconst numbers = [1, 2, 3, 4, 5];\n\n// Basic usage\nnumbers.forEach(num => console.log(num));\n\n// With index and array\nnumbers.forEach((num, index, arr) => {\n  console.log(`Index ${index}: ${num}`);\n});\n\n// Note: forEach doesn't return a new array\nconst result = numbers.forEach(num => num * 2);\nconsole.log(result); // undefined\n```\n\n**2. map() - Creates new array with transformed elements:**\n```javascript\nconst numbers = [1, 2, 3, 4, 5];\n\n// Double each number\nconst doubled = numbers.map(num => num * 2);\nconsole.log(doubled); // [2, 4, 6, 8, 10]\n\n// Transform objects\nconst users = [\n  { name: 'John', age: 30 },\n  { name: 'Jane', age: 25 }\n];\n\nconst names = users.map(user => user.name);\nconsole.log(names); // ['John', 'Jane']\n\n// With index\nconst indexed = numbers.map((num, index) => `${index}: ${num}`);\nconsole.log(indexed); // ['0: 1', '1: 2', '2: 3', '3: 4', '4: 5']\n```\n\n**3. filter() - Creates new array with elements that pass test:**\n```javascript\nconst numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n// Filter even numbers\nconst evens = numbers.filter(num => num % 2 === 0);\nconsole.log(evens); // [2, 4, 6, 8, 10]\n\n// Filter objects\nconst users = [\n  { name: 'John', age: 30, active: true },\n  { name: 'Jane', age: 25, active: false },\n  { name: 'Bob', age: 35, active: true }\n];\n\nconst activeUsers = users.filter(user => user.active);\nconst adults = users.filter(user => user.age >= 30);\n\n// Chain with other methods\nconst activeAdultNames = users\n  .filter(user => user.active && user.age >= 30)\n  .map(user => user.name);\nconsole.log(activeAdultNames); // ['John', 'Bob']\n```\n\n**4. reduce() - Reduces array to single value:**\n```javascript\nconst numbers = [1, 2, 3, 4, 5];\n\n// Sum all numbers\nconst sum = numbers.reduce((acc, num) => acc + num, 0);\nconsole.log(sum); // 15\n\n// Find maximum\nconst max = numbers.reduce((max, num) => num > max ? num : max);\nconsole.log(max); // 5\n\n// Group objects\nconst users = [\n  { name: 'John', department: 'IT' },\n  { name: 'Jane', department: 'HR' },\n  { name: 'Bob', department: 'IT' },\n  { name: 'Alice', department: 'HR' }\n];\n\nconst groupedByDept = users.reduce((groups, user) => {\n  const dept = user.department;\n  if (!groups[dept]) {\n    groups[dept] = [];\n  }\n  groups[dept].push(user);\n  return groups;\n}, {});\n\nconsole.log(groupedByDept);\n// { IT: [{name: 'John', ...}, {name: 'Bob', ...}], HR: [...] }\n\n// Count occurrences\nconst fruits = ['apple', 'banana', 'apple', 'orange', 'banana', 'apple'];\nconst count = fruits.reduce((acc, fruit) => {\n  acc[fruit] = (acc[fruit] || 0) + 1;\n  return acc;\n}, {});\nconsole.log(count); // { apple: 3, banana: 2, orange: 1 }\n```\n\n**Method Chaining:**\n```javascript\nconst data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\nconst result = data\n  .filter(num => num % 2 === 0)  // [2, 4, 6, 8, 10]\n  .map(num => num * num)         // [4, 16, 36, 64, 100]\n  .reduce((sum, num) => sum + num, 0); // 220\n\nconsole.log(result); // 220\n```"
  }
]
