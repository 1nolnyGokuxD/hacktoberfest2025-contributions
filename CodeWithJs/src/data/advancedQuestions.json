[
  {
    "id": "advanced-1",
    "question": "What is call, apply, and bind in JavaScript?",
    "answer": "These methods allow you to explicitly set the `this` context and invoke functions with a specific context.\n\n**call() - Invokes function immediately with specified `this` and arguments:**\n```javascript\nfunction greet(greeting, punctuation) {\n  return `${greeting}, ${this.name}${punctuation}`;\n}\n\nconst person = { name: 'John' };\n\n// Using call\nconst result = greet.call(person, 'Hello', '!');\nconsole.log(result); // \"Hello, John!\"\n```\n\n**apply() - Similar to call but takes arguments as array:**\n```javascript\nfunction introduce(age, city) {\n  return `I'm ${this.name}, ${age} years old from ${city}`;\n}\n\nconst person = { name: 'Jane' };\n\n// Using apply\nconst result = introduce.apply(person, [25, 'New York']);\nconsole.log(result); // \"I'm Jane, 25 years old from New York\"\n\n// Useful for finding max in array\nconst numbers = [1, 5, 3, 9, 2];\nconst max = Math.max.apply(null, numbers);\nconsole.log(max); // 9\n```\n\n**bind() - Returns new function with bound `this` (doesn't invoke immediately):**\n```javascript\nconst person = { name: 'Bob' };\n\nfunction sayHello() {\n  return `Hello, I'm ${this.name}`;\n}\n\n// Using bind\nconst boundSayHello = sayHello.bind(person);\nconsole.log(boundSayHello()); // \"Hello, I'm Bob\"\n\n// Partial application with bind\nfunction multiply(a, b) {\n  return a * b;\n}\n\nconst double = multiply.bind(null, 2);\nconsole.log(double(5)); // 10\n\n// Event handler example\nclass Counter {\n  constructor() {\n    this.count = 0;\n    this.button = document.querySelector('#btn');\n    // Without bind, 'this' would refer to the button\n    this.button.addEventListener('click', this.increment.bind(this));\n  }\n  \n  increment() {\n    this.count++;\n    console.log(this.count);\n  }\n}\n```\n\n**Comparison:**\n- **call**: Immediate invocation, arguments passed individually\n- **apply**: Immediate invocation, arguments passed as array\n- **bind**: Returns new function, doesn't invoke immediately"
  },
  {
    "id": "advanced-2",
    "question": "What are JavaScript Generators and how do they work?",
    "answer": "Generators are functions that can pause and resume their execution, allowing them to produce a sequence of values over time.\n\n**Generator Function Syntax:**\n```javascript\nfunction* simpleGenerator() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nconst gen = simpleGenerator();\nconsole.log(gen.next()); // { value: 1, done: false }\nconsole.log(gen.next()); // { value: 2, done: false }\nconsole.log(gen.next()); // { value: 3, done: false }\nconsole.log(gen.next()); // { value: undefined, done: true }\n```\n\n**Generator with return value:**\n```javascript\nfunction* generatorWithReturn() {\n  yield 1;\n  yield 2;\n  return 3;\n  yield 4; // This will never execute\n}\n\nconst gen = generatorWithReturn();\nconsole.log(gen.next()); // { value: 1, done: false }\nconsole.log(gen.next()); // { value: 2, done: false }\nconsole.log(gen.next()); // { value: 3, done: true }\n```\n\n**Infinite Generator:**\n```javascript\nfunction* infiniteSequence() {\n  let i = 0;\n  while (true) {\n    yield i++;\n  }\n}\n\nconst seq = infiniteSequence();\nconsole.log(seq.next().value); // 0\nconsole.log(seq.next().value); // 1\nconsole.log(seq.next().value); // 2\n```\n\n**Fibonacci Generator:**\n```javascript\nfunction* fibonacciGenerator() {\n  let [prev, curr] = [0, 1];\n  \n  while (true) {\n    yield curr;\n    [prev, curr] = [curr, prev + curr];\n  }\n}\n\nconst fib = fibonacciGenerator();\nfor (let i = 0; i < 10; i++) {\n  console.log(fib.next().value);\n}\n// Output: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55\n```\n\n**Generator with yield*:**\n```javascript\nfunction* gen1() {\n  yield 1;\n  yield 2;\n}\n\nfunction* gen2() {\n  yield 3;\n  yield 4;\n}\n\nfunction* combinedGenerator() {\n  yield* gen1();\n  yield* gen2();\n  yield 5;\n}\n\nconst combined = combinedGenerator();\nfor (const value of combined) {\n  console.log(value); // 1, 2, 3, 4, 5\n}\n```\n\n**Passing values to generators:**\n```javascript\nfunction* twoWayGenerator() {\n  const input1 = yield 'First yield';\n  console.log('Received:', input1);\n  \n  const input2 = yield 'Second yield';\n  console.log('Received:', input2);\n  \n  return 'Done';\n}\n\nconst gen = twoWayGenerator();\nconsole.log(gen.next());           // { value: 'First yield', done: false }\nconsole.log(gen.next('Hello'));    // Received: Hello, { value: 'Second yield', done: false }\nconsole.log(gen.next('World'));    // Received: World, { value: 'Done', done: true }\n```\n\n**Use Cases:**\n- Iterator implementation\n- Lazy evaluation\n- Async programming (before async/await)\n- State machines\n- Data streaming"
  },
  {
    "id": "advanced-3",
    "question": "What are Symbols in JavaScript and when would you use them?",
    "answer": "Symbols are a primitive data type introduced in ES6 that represents a unique identifier. Every symbol value is unique, even if they have the same description.\n\n**Creating Symbols:**\n```javascript\n// Basic symbol creation\nconst sym1 = Symbol();\nconst sym2 = Symbol();\nconsole.log(sym1 === sym2); // false (each symbol is unique)\n\n// Symbol with description\nconst sym3 = Symbol('description');\nconst sym4 = Symbol('description');\nconsole.log(sym3 === sym4); // false (still unique)\nconsole.log(sym3.toString()); // \"Symbol(description)\"\n```\n\n**Using Symbols as Object Properties:**\n```javascript\nconst id = Symbol('id');\nconst name = Symbol('name');\n\nconst user = {\n  [id]: 123,\n  [name]: 'John',\n  age: 30\n};\n\nconsole.log(user[id]); // 123\nconsole.log(user[name]); // 'John'\n\n// Symbols are not enumerable in for...in loops\nfor (let key in user) {\n  console.log(key); // Only logs 'age'\n}\n\n// Object.keys() doesn't include symbols\nconsole.log(Object.keys(user)); // ['age']\n\n// Get symbol properties\nconsole.log(Object.getOwnPropertySymbols(user)); // [Symbol(id), Symbol(name)]\n```\n\n**Global Symbol Registry:**\n```javascript\n// Create/get symbol from global registry\nconst globalSym1 = Symbol.for('app.id');\nconst globalSym2 = Symbol.for('app.id');\nconsole.log(globalSym1 === globalSym2); // true (same symbol from registry)\n\n// Get key for symbol\nconsole.log(Symbol.keyFor(globalSym1)); // 'app.id'\n```\n\n**Well-known Symbols:**\n```javascript\n// Symbol.iterator - makes object iterable\nconst iterableObj = {\n  data: [1, 2, 3],\n  [Symbol.iterator]() {\n    let index = 0;\n    const data = this.data;\n    \n    return {\n      next() {\n        if (index < data.length) {\n          return { value: data[index++], done: false };\n        }\n        return { done: true };\n      }\n    };\n  }\n};\n\nfor (const value of iterableObj) {\n  console.log(value); // 1, 2, 3\n}\n\n// Symbol.toStringTag - custom toString behavior\nclass MyClass {\n  get [Symbol.toStringTag]() {\n    return 'MyClass';\n  }\n}\n\nconst obj = new MyClass();\nconsole.log(obj.toString()); // \"[object MyClass]\"\n\n// Symbol.toPrimitive - custom type conversion\nconst obj2 = {\n  [Symbol.toPrimitive](hint) {\n    if (hint === 'number') return 42;\n    if (hint === 'string') return 'hello';\n    return true;\n  }\n};\n\nconsole.log(+obj2);     // 42 (number hint)\nconsole.log(`${obj2}`); // \"hello\" (string hint)\nconsole.log(!!obj2);    // true (default hint)\n```\n\n**Practical Use Cases:**\n\n**1. Private-like Properties:**\n```javascript\nconst _private = Symbol('private');\n\nclass MyClass {\n  constructor() {\n    this[_private] = 'secret data';\n    this.public = 'public data';\n  }\n  \n  getPrivate() {\n    return this[_private];\n  }\n}\n\nconst instance = new MyClass();\nconsole.log(instance.public); // 'public data'\nconsole.log(instance[_private]); // undefined (symbol not accessible)\nconsole.log(instance.getPrivate()); // 'secret data'\n```\n\n**2. Constants:**\n```javascript\nconst STATUS = {\n  PENDING: Symbol('pending'),\n  RESOLVED: Symbol('resolved'),\n  REJECTED: Symbol('rejected')\n};\n\nfunction handleStatus(status) {\n  switch (status) {\n    case STATUS.PENDING:\n      return 'Processing...';\n    case STATUS.RESOLVED:\n      return 'Success!';\n    case STATUS.REJECTED:\n      return 'Error occurred';\n  }\n}\n```\n\n**3. Avoiding Property Name Collisions:**\n```javascript\n// Library A\nconst LibA = {\n  id: Symbol('libA.id')\n};\n\n// Library B\nconst LibB = {\n  id: Symbol('libB.id')\n};\n\n// No collision even with same property names\nconst obj = {\n  [LibA.id]: 'Library A data',\n  [LibB.id]: 'Library B data'\n};\n```"
  },
  {
    "id": "advanced-4",
    "question": "Explain WeakMap and WeakSet in JavaScript",
    "answer": "WeakMap and WeakSet are \"weak\" collections that hold weak references to their keys, allowing for garbage collection when there are no other references.\n\n**WeakMap:**\n\nA WeakMap is similar to Map but with key differences:\n- Keys must be objects (not primitives)\n- Keys are weakly referenced\n- Not iterable\n- No size property\n- Keys can be garbage collected\n\n```javascript\n// Basic WeakMap usage\nconst wm = new WeakMap();\n\nlet obj1 = { name: 'John' };\nlet obj2 = { name: 'Jane' };\n\n// Set values\nwm.set(obj1, 'additional data for obj1');\nwm.set(obj2, 'additional data for obj2');\n\n// Get values\nconsole.log(wm.get(obj1)); // 'additional data for obj1'\nconsole.log(wm.has(obj2)); // true\n\n// Delete\nwm.delete(obj1);\nconsole.log(wm.has(obj1)); // false\n\n// When obj2 goes out of scope, it can be garbage collected\nobj2 = null; // Now the entry in WeakMap can be garbage collected\n```\n\n**WeakMap Use Cases:**\n\n**1. Private Data Storage:**\n```javascript\nconst privateData = new WeakMap();\n\nclass Person {\n  constructor(name, age) {\n    this.name = name;\n    // Store private data\n    privateData.set(this, { age, ssn: '123-45-6789' });\n  }\n  \n  getAge() {\n    return privateData.get(this).age;\n  }\n  \n  getSSN() {\n    return privateData.get(this).ssn;\n  }\n}\n\nconst person = new Person('John', 30);\nconsole.log(person.getAge()); // 30\nconsole.log(person.name);     // 'John'\n// No way to access private data directly\n```\n\n**2. DOM Node Metadata:**\n```javascript\nconst nodeMetadata = new WeakMap();\n\nfunction attachMetadata(element, data) {\n  nodeMetadata.set(element, data);\n}\n\nfunction getMetadata(element) {\n  return nodeMetadata.get(element);\n}\n\n// Usage\nconst button = document.querySelector('#myButton');\nattachMetadata(button, {\n  clickCount: 0,\n  created: new Date()\n});\n\n// When the button is removed from DOM and no other references exist,\n// the metadata will also be garbage collected\n```\n\n**WeakSet:**\n\nA WeakSet is similar to Set but with weak references:\n- Values must be objects\n- Values are weakly referenced\n- Not iterable\n- No size property\n\n```javascript\nconst ws = new WeakSet();\n\nlet obj1 = { id: 1 };\nlet obj2 = { id: 2 };\n\n// Add objects\nws.add(obj1);\nws.add(obj2);\n\n// Check if object exists\nconsole.log(ws.has(obj1)); // true\n\n// Delete object\nws.delete(obj1);\nconsole.log(ws.has(obj1)); // false\n\n// When obj2 goes out of scope, it can be garbage collected\nobj2 = null;\n```\n\n**WeakSet Use Cases:**\n\n**1. Tracking Object States:**\n```javascript\nconst processedObjects = new WeakSet();\n\nfunction processObject(obj) {\n  if (processedObjects.has(obj)) {\n    console.log('Already processed');\n    return;\n  }\n  \n  // Process the object\n  console.log('Processing object...');\n  \n  // Mark as processed\n  processedObjects.add(obj);\n}\n\nconst item1 = { data: 'test' };\nprocessObject(item1); // \"Processing object...\"\nprocessObject(item1); // \"Already processed\"\n```\n\n**2. Authorized Objects:**\n```javascript\nconst authorizedUsers = new WeakSet();\n\nclass SecureArea {\n  static authorize(user) {\n    authorizedUsers.add(user);\n  }\n  \n  static isAuthorized(user) {\n    return authorizedUsers.has(user);\n  }\n  \n  static revokeAccess(user) {\n    authorizedUsers.delete(user);\n  }\n  \n  enter(user) {\n    if (SecureArea.isAuthorized(user)) {\n      console.log('Access granted');\n    } else {\n      console.log('Access denied');\n    }\n  }\n}\n\nconst user1 = { name: 'John' };\nconst secureArea = new SecureArea();\n\nsecureArea.enter(user1); // \"Access denied\"\nSecureArea.authorize(user1);\nsecureArea.enter(user1); // \"Access granted\"\n```\n\n**Key Differences from Map/Set:**\n\n| Feature | Map/Set | WeakMap/WeakSet |\n|---------|---------|----------------|\n| Keys/Values | Any type | Objects only |\n| Iterable | Yes | No |\n| Size property | Yes | No |\n| Garbage collection | No | Yes (weak references) |\n| Use case | General collections | Memory-efficient metadata |\n\n**Memory Management Benefits:**\n```javascript\n// Regular Map - prevents garbage collection\nconst regularMap = new Map();\nlet heavyObject = new ArrayBuffer(1024 * 1024); // 1MB\nregularMap.set('key', heavyObject);\nheavyObject = null; // Object still referenced by Map, can't be GC'd\n\n// WeakMap - allows garbage collection\nconst weakMap = new WeakMap();\nlet keyObject = {};\nlet heavyObject2 = new ArrayBuffer(1024 * 1024); // 1MB\nweakMap.set(keyObject, heavyObject2);\nkeyObject = null; // Both objects can now be garbage collected\nheavyObject2 = null;\n```"
  },
  {
    "id": "advanced-5",
    "question": "What is Proxy in JavaScript and how does it work?",
    "answer": "Proxy allows you to intercept and customize operations performed on objects (property lookup, assignment, enumeration, function invocation, etc.) by defining custom handlers.\n\n**Basic Proxy Syntax:**\n```javascript\nconst proxy = new Proxy(target, handler);\n```\n\n**Simple Example:**\n```javascript\nconst person = {\n  name: 'John',\n  age: 30\n};\n\nconst personProxy = new Proxy(person, {\n  get(target, property) {\n    console.log(`Getting ${property}`);\n    return target[property];\n  },\n  \n  set(target, property, value) {\n    console.log(`Setting ${property} to ${value}`);\n    target[property] = value;\n    return true;\n  }\n});\n\nconsole.log(personProxy.name); // \"Getting name\", then \"John\"\npersonProxy.age = 31;          // \"Setting age to 31\"\n```\n\n**Common Handler Methods (Traps):**\n\n**1. get trap - Property access:**\n```javascript\nconst obj = { a: 1, b: 2 };\n\nconst proxy = new Proxy(obj, {\n  get(target, property) {\n    if (property in target) {\n      return target[property];\n    } else {\n      return `Property '${property}' doesn't exist`;\n    }\n  }\n});\n\nconsole.log(proxy.a); // 1\nconsole.log(proxy.c); // \"Property 'c' doesn't exist\"\n```\n\n**2. set trap - Property assignment:**\n```javascript\nconst validatedObj = new Proxy({}, {\n  set(target, property, value) {\n    if (property === 'age' && typeof value !== 'number') {\n      throw new TypeError('Age must be a number');\n    }\n    \n    if (property === 'name' && typeof value !== 'string') {\n      throw new TypeError('Name must be a string');\n    }\n    \n    target[property] = value;\n    return true;\n  }\n});\n\nvalidatedObj.name = 'John'; // OK\nvalidatedObj.age = 30;      // OK\n// validatedObj.age = '30';  // TypeError: Age must be a number\n```\n\n**3. has trap - 'in' operator:**\n```javascript\nconst secretObj = { visible: true, _secret: 'hidden' };\n\nconst proxy = new Proxy(secretObj, {\n  has(target, property) {\n    if (property.startsWith('_')) {\n      return false; // Hide properties starting with underscore\n    }\n    return property in target;\n  }\n});\n\nconsole.log('visible' in proxy); // true\nconsole.log('_secret' in proxy); // false (even though it exists)\n```\n\n**4. deleteProperty trap - delete operator:**\n```javascript\nconst protectedObj = { \n  public: 'everyone can delete',\n  protected: 'cannot delete'\n};\n\nconst proxy = new Proxy(protectedObj, {\n  deleteProperty(target, property) {\n    if (property === 'protected') {\n      console.log('Cannot delete protected property');\n      return false;\n    }\n    delete target[property];\n    return true;\n  }\n});\n\ndelete proxy.public;    // OK\ndelete proxy.protected; // \"Cannot delete protected property\"\nconsole.log(proxy.protected); // still exists\n```\n\n**5. ownKeys trap - Object.keys(), for...in:**\n```javascript\nconst obj = { a: 1, b: 2, _private: 3 };\n\nconst proxy = new Proxy(obj, {\n  ownKeys(target) {\n    // Filter out private properties\n    return Object.keys(target).filter(key => !key.startsWith('_'));\n  }\n});\n\nconsole.log(Object.keys(proxy)); // ['a', 'b'] (excludes '_private')\n```\n\n**6. apply trap - Function calls:**\n```javascript\nfunction greet(name) {\n  return `Hello, ${name}!`;\n}\n\nconst greetProxy = new Proxy(greet, {\n  apply(target, thisArg, argumentsList) {\n    console.log('Function called with:', argumentsList);\n    return target.apply(thisArg, argumentsList);\n  }\n});\n\nconsole.log(greetProxy('John')); \n// \"Function called with: ['John']\"\n// \"Hello, John!\"\n```\n\n**7. construct trap - new operator:**\n```javascript\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nconst PersonProxy = new Proxy(Person, {\n  construct(target, argumentsList) {\n    console.log('Creating new instance with:', argumentsList);\n    return new target(...argumentsList);\n  }\n});\n\nconst john = new PersonProxy('John');\n// \"Creating new instance with: ['John']\"\nconsole.log(john.name); // \"John\"\n```\n\n**Advanced Use Cases:**\n\n**1. Array Negative Indexing:**\n```javascript\nconst array = [1, 2, 3, 4, 5];\n\nconst negativeArray = new Proxy(array, {\n  get(target, property) {\n    if (typeof property === 'string' && /^-\\d+$/.test(property)) {\n      const index = target.length + parseInt(property);\n      return target[index];\n    }\n    return target[property];\n  }\n});\n\nconsole.log(negativeArray[-1]); // 5 (last element)\nconsole.log(negativeArray[-2]); // 4 (second to last)\n```\n\n**2. Observable Objects:**\n```javascript\nfunction createObservable(target, onChange) {\n  return new Proxy(target, {\n    set(obj, property, value) {\n      const oldValue = obj[property];\n      obj[property] = value;\n      onChange(property, oldValue, value);\n      return true;\n    }\n  });\n}\n\nconst data = { name: 'John', age: 30 };\nconst observable = createObservable(data, (prop, oldVal, newVal) => {\n  console.log(`${prop} changed from ${oldVal} to ${newVal}`);\n});\n\nobservable.age = 31; // \"age changed from 30 to 31\"\n```\n\n**3. Default Values:**\n```javascript\nfunction withDefaults(target, defaults) {\n  return new Proxy(target, {\n    get(obj, property) {\n      return property in obj ? obj[property] : defaults[property];\n    }\n  });\n}\n\nconst config = withDefaults(\n  { apiUrl: 'https://api.example.com' },\n  { timeout: 5000, retries: 3 }\n);\n\nconsole.log(config.apiUrl);  // \"https://api.example.com\"\nconsole.log(config.timeout); // 5000 (from defaults)\nconsole.log(config.retries); // 3 (from defaults)\n```\n\n**4. Method Chaining:**\n```javascript\nconst chainable = new Proxy({}, {\n  get(target, property) {\n    if (property === 'result') {\n      return target;\n    }\n    \n    return function(...args) {\n      target[property] = args.length === 1 ? args[0] : args;\n      return chainable;\n    };\n  }\n});\n\nconst result = chainable\n  .name('John')\n  .age(30)\n  .skills(['JavaScript', 'Python'])\n  .result;\n\nconsole.log(result); \n// { name: 'John', age: 30, skills: ['JavaScript', 'Python'] }\n```\n\n**Proxy vs Object.defineProperty:**\n- Proxy can intercept more operations\n- Proxy works on entire object, not individual properties\n- Proxy can handle dynamic properties\n- Object.defineProperty has better browser support"
  }
]
