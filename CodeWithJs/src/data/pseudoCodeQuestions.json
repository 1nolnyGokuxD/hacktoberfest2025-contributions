[
  {
    "id": "pseudo-1",
    "question": "Write a function to find the maximum number in an array",
    "answer": "**Problem:** Find the maximum number in an array of integers.\n\n**Approach 1: Using built-in Math.max()**\n```javascript\nfunction findMax(arr) {\n  return Math.max(...arr);\n}\n\n// Usage\nconst numbers = [3, 7, 2, 9, 1, 8];\nconsole.log(findMax(numbers)); // 9\n```\n\n**Approach 2: Using reduce()**\n```javascript\nfunction findMax(arr) {\n  return arr.reduce((max, current) => current > max ? current : max);\n}\n```\n\n**Approach 3: Traditional loop**\n```javascript\nfunction findMax(arr) {\n  if (arr.length === 0) return undefined;\n  \n  let max = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n    }\n  }\n  return max;\n}\n```\n\n**Approach 4: Recursive solution**\n```javascript\nfunction findMax(arr, index = 0, max = arr[0]) {\n  if (index >= arr.length) return max;\n  \n  if (arr[index] > max) {\n    max = arr[index];\n  }\n  \n  return findMax(arr, index + 1, max);\n}\n```\n\n**Time Complexity:** O(n)\n**Space Complexity:** O(1) for iterative, O(n) for recursive"
  },
  {
    "id": "pseudo-2",
    "question": "Implement a function to reverse a string",
    "answer": "**Problem:** Reverse a string without using built-in reverse methods.\n\n**Approach 1: Using split, reverse, join**\n```javascript\nfunction reverseString(str) {\n  return str.split('').reverse().join('');\n}\n\n// Usage\nconsole.log(reverseString('hello')); // 'olleh'\n```\n\n**Approach 2: Using a loop (from end to start)**\n```javascript\nfunction reverseString(str) {\n  let reversed = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversed += str[i];\n  }\n  return reversed;\n}\n```\n\n**Approach 3: Using recursion**\n```javascript\nfunction reverseString(str) {\n  if (str === '') return '';\n  return str[str.length - 1] + reverseString(str.slice(0, -1));\n}\n```\n\n**Approach 4: Two pointers technique**\n```javascript\nfunction reverseString(str) {\n  const arr = str.split('');\n  let left = 0;\n  let right = arr.length - 1;\n  \n  while (left < right) {\n    // Swap characters\n    [arr[left], arr[right]] = [arr[right], arr[left]];\n    left++;\n    right--;\n  }\n  \n  return arr.join('');\n}\n```\n\n**Approach 5: Using Array.from and map**\n```javascript\nfunction reverseString(str) {\n  return Array.from(str, (_, index) => str[str.length - 1 - index]).join('');\n}\n```\n\n**Time Complexity:** O(n)\n**Space Complexity:** O(n)"
  },
  {
    "id": "pseudo-3",
    "question": "Check if a string is a palindrome",
    "answer": "**Problem:** Check if a string reads the same forwards and backwards.\n\n**Approach 1: Simple comparison with reverse**\n```javascript\nfunction isPalindrome(str) {\n  const cleaned = str.toLowerCase().replace(/[^a-z0-9]/g, '');\n  return cleaned === cleaned.split('').reverse().join('');\n}\n\n// Usage\nconsole.log(isPalindrome('A man a plan a canal Panama')); // true\nconsole.log(isPalindrome('race a car')); // false\n```\n\n**Approach 2: Two pointers technique**\n```javascript\nfunction isPalindrome(str) {\n  const cleaned = str.toLowerCase().replace(/[^a-z0-9]/g, '');\n  let left = 0;\n  let right = cleaned.length - 1;\n  \n  while (left < right) {\n    if (cleaned[left] !== cleaned[right]) {\n      return false;\n    }\n    left++;\n    right--;\n  }\n  \n  return true;\n}\n```\n\n**Approach 3: Recursive solution**\n```javascript\nfunction isPalindrome(str, left = 0, right = str.length - 1) {\n  // Clean the string first (only on first call)\n  if (left === 0 && right === str.length - 1) {\n    str = str.toLowerCase().replace(/[^a-z0-9]/g, '');\n    right = str.length - 1;\n  }\n  \n  if (left >= right) return true;\n  if (str[left] !== str[right]) return false;\n  \n  return isPalindrome(str, left + 1, right - 1);\n}\n```\n\n**Approach 4: Using every method**\n```javascript\nfunction isPalindrome(str) {\n  const cleaned = str.toLowerCase().replace(/[^a-z0-9]/g, '');\n  const length = cleaned.length;\n  \n  return cleaned.split('').every((char, index) => {\n    return char === cleaned[length - 1 - index];\n  });\n}\n```\n\n**Case-insensitive and alphanumeric only:**\n```javascript\nfunction isPalindromeAlphanumeric(str) {\n  const cleaned = str.toLowerCase().replace(/[^a-z0-9]/g, '');\n  let left = 0;\n  let right = cleaned.length - 1;\n  \n  while (left < right) {\n    if (cleaned[left] !== cleaned[right]) {\n      return false;\n    }\n    left++;\n    right--;\n  }\n  \n  return true;\n}\n\n// Test cases\nconsole.log(isPalindromeAlphanumeric('A man, a plan, a canal: Panama')); // true\nconsole.log(isPalindromeAlphanumeric('Was it a car or a cat I saw?')); // true\nconsole.log(isPalindromeAlphanumeric('No 'x' in Nixon')); // true\n```\n\n**Time Complexity:** O(n)\n**Space Complexity:** O(1) for two-pointer, O(n) for others"
  },
  {
    "id": "pseudo-4",
    "question": "Find the first non-repeating character in a string",
    "answer": "**Problem:** Find the first character that appears exactly once in a string.\n\n**Approach 1: Using Map to count frequencies**\n```javascript\nfunction firstNonRepeating(str) {\n  const charCount = new Map();\n  \n  // Count frequency of each character\n  for (let char of str) {\n    charCount.set(char, (charCount.get(char) || 0) + 1);\n  }\n  \n  // Find first character with count of 1\n  for (let char of str) {\n    if (charCount.get(char) === 1) {\n      return char;\n    }\n  }\n  \n  return null; // No non-repeating character found\n}\n\n// Usage\nconsole.log(firstNonRepeating('leetcode')); // 'l'\nconsole.log(firstNonRepeating('loveleetcode')); // 'v'\nconsole.log(firstNonRepeating('aabbcc')); // null\n```\n\n**Approach 2: Using object for counting**\n```javascript\nfunction firstNonRepeating(str) {\n  const charCount = {};\n  \n  // Count frequencies\n  for (let char of str) {\n    charCount[char] = (charCount[char] || 0) + 1;\n  }\n  \n  // Find first non-repeating\n  for (let char of str) {\n    if (charCount[char] === 1) {\n      return char;\n    }\n  }\n  \n  return null;\n}\n```\n\n**Approach 3: Using indexOf and lastIndexOf**\n```javascript\nfunction firstNonRepeating(str) {\n  for (let i = 0; i < str.length; i++) {\n    const char = str[i];\n    // If first occurrence equals last occurrence, it's unique\n    if (str.indexOf(char) === str.lastIndexOf(char)) {\n      return char;\n    }\n  }\n  return null;\n}\n```\n\n**Approach 4: Two-pass with Set**\n```javascript\nfunction firstNonRepeating(str) {\n  const seen = new Set();\n  const repeated = new Set();\n  \n  // Mark repeated characters\n  for (let char of str) {\n    if (seen.has(char)) {\n      repeated.add(char);\n    } else {\n      seen.add(char);\n    }\n  }\n  \n  // Find first non-repeated character\n  for (let char of str) {\n    if (!repeated.has(char)) {\n      return char;\n    }\n  }\n  \n  return null;\n}\n```\n\n**Approach 5: Return index instead of character**\n```javascript\nfunction firstNonRepeatingIndex(str) {\n  const charCount = new Map();\n  \n  // Count frequencies\n  for (let char of str) {\n    charCount.set(char, (charCount.get(char) || 0) + 1);\n  }\n  \n  // Find first non-repeating index\n  for (let i = 0; i < str.length; i++) {\n    if (charCount.get(str[i]) === 1) {\n      return i;\n    }\n  }\n  \n  return -1; // No non-repeating character found\n}\n\n// Usage\nconsole.log(firstNonRepeatingIndex('leetcode')); // 0\nconsole.log(firstNonRepeatingIndex('loveleetcode')); // 2\nconsole.log(firstNonRepeatingIndex('aabbcc')); // -1\n```\n\n**Time Complexity:** O(n)\n**Space Complexity:** O(k) where k is the number of unique characters"
  },
  {
    "id": "pseudo-5",
    "question": "Implement binary search algorithm",
    "answer": "**Problem:** Search for a target value in a sorted array using binary search.\n\n**Iterative Approach:**\n```javascript\nfunction binarySearch(arr, target) {\n  let left = 0;\n  let right = arr.length - 1;\n  \n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    \n    if (arr[mid] === target) {\n      return mid; // Found target, return index\n    } else if (arr[mid] < target) {\n      left = mid + 1; // Search right half\n    } else {\n      right = mid - 1; // Search left half\n    }\n  }\n  \n  return -1; // Target not found\n}\n\n// Usage\nconst sortedArray = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19];\nconsole.log(binarySearch(sortedArray, 7)); // 3\nconsole.log(binarySearch(sortedArray, 6)); // -1\n```\n\n**Recursive Approach:**\n```javascript\nfunction binarySearchRecursive(arr, target, left = 0, right = arr.length - 1) {\n  if (left > right) {\n    return -1; // Base case: target not found\n  }\n  \n  const mid = Math.floor((left + right) / 2);\n  \n  if (arr[mid] === target) {\n    return mid; // Found target\n  } else if (arr[mid] < target) {\n    return binarySearchRecursive(arr, target, mid + 1, right);\n  } else {\n    return binarySearchRecursive(arr, target, left, mid - 1);\n  }\n}\n```\n\n**Binary Search with Range (Find First/Last Occurrence):**\n```javascript\n// Find first occurrence of target\nfunction findFirst(arr, target) {\n  let left = 0;\n  let right = arr.length - 1;\n  let result = -1;\n  \n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    \n    if (arr[mid] === target) {\n      result = mid;\n      right = mid - 1; // Continue searching left for first occurrence\n    } else if (arr[mid] < target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n  \n  return result;\n}\n\n// Find last occurrence of target\nfunction findLast(arr, target) {\n  let left = 0;\n  let right = arr.length - 1;\n  let result = -1;\n  \n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    \n    if (arr[mid] === target) {\n      result = mid;\n      left = mid + 1; // Continue searching right for last occurrence\n    } else if (arr[mid] < target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n  \n  return result;\n}\n\n// Find range of target values\nfunction searchRange(arr, target) {\n  const first = findFirst(arr, target);\n  const last = findLast(arr, target);\n  return [first, last];\n}\n\n// Usage\nconst duplicateArray = [5, 7, 7, 8, 8, 10];\nconsole.log(searchRange(duplicateArray, 8)); // [3, 4]\nconsole.log(searchRange(duplicateArray, 6)); // [-1, -1]\n```\n\n**Binary Search for Insertion Point:**\n```javascript\nfunction searchInsert(arr, target) {\n  let left = 0;\n  let right = arr.length - 1;\n  \n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    \n    if (arr[mid] === target) {\n      return mid;\n    } else if (arr[mid] < target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n  \n  return left; // Position where target should be inserted\n}\n\n// Usage\nconst nums = [1, 3, 5, 6];\nconsole.log(searchInsert(nums, 5)); // 2\nconsole.log(searchInsert(nums, 2)); // 1\nconsole.log(searchInsert(nums, 7)); // 4\nconsole.log(searchInsert(nums, 0)); // 0\n```\n\n**Binary Search in Rotated Sorted Array:**\n```javascript\nfunction searchRotated(arr, target) {\n  let left = 0;\n  let right = arr.length - 1;\n  \n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    \n    if (arr[mid] === target) {\n      return mid;\n    }\n    \n    // Check which half is sorted\n    if (arr[left] <= arr[mid]) {\n      // Left half is sorted\n      if (target >= arr[left] && target < arr[mid]) {\n        right = mid - 1;\n      } else {\n        left = mid + 1;\n      }\n    } else {\n      // Right half is sorted\n      if (target > arr[mid] && target <= arr[right]) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n  }\n  \n  return -1;\n}\n\n// Usage\nconst rotated = [4, 5, 6, 7, 0, 1, 2];\nconsole.log(searchRotated(rotated, 0)); // 4\nconsole.log(searchRotated(rotated, 3)); // -1\n```\n\n**Time Complexity:** O(log n)\n**Space Complexity:** O(1) for iterative, O(log n) for recursive"
  },
  {
    "id": "pseudo-6",
    "question": "Write a function to check if two strings are anagrams",
    "answer": "**Problem:** Determine if two strings are anagrams (contain the same characters with the same frequency).\n\n**Approach 1: Sorting both strings**\n```javascript\nfunction areAnagrams(str1, str2) {\n  // Remove spaces and convert to lowercase\n  const clean1 = str1.replace(/\\s+/g, '').toLowerCase();\n  const clean2 = str2.replace(/\\s+/g, '').toLowerCase();\n  \n  // Check if lengths are different\n  if (clean1.length !== clean2.length) {\n    return false;\n  }\n  \n  // Sort both strings and compare\n  return clean1.split('').sort().join('') === clean2.split('').sort().join('');\n}\n\n// Usage\nconsole.log(areAnagrams('listen', 'silent')); // true\nconsole.log(areAnagrams('hello', 'bello')); // false\nconsole.log(areAnagrams('A gentleman', 'Elegant man')); // true\n```\n\n**Approach 2: Character frequency counting with Map**\n```javascript\nfunction areAnagrams(str1, str2) {\n  const clean1 = str1.replace(/\\s+/g, '').toLowerCase();\n  const clean2 = str2.replace(/\\s+/g, '').toLowerCase();\n  \n  if (clean1.length !== clean2.length) {\n    return false;\n  }\n  \n  const charCount = new Map();\n  \n  // Count characters in first string\n  for (let char of clean1) {\n    charCount.set(char, (charCount.get(char) || 0) + 1);\n  }\n  \n  // Subtract characters from second string\n  for (let char of clean2) {\n    if (!charCount.has(char)) {\n      return false;\n    }\n    charCount.set(char, charCount.get(char) - 1);\n    if (charCount.get(char) === 0) {\n      charCount.delete(char);\n    }\n  }\n  \n  return charCount.size === 0;\n}\n```\n\n**Approach 3: Using object for character counting**\n```javascript\nfunction areAnagrams(str1, str2) {\n  const clean1 = str1.replace(/\\s+/g, '').toLowerCase();\n  const clean2 = str2.replace(/\\s+/g, '').toLowerCase();\n  \n  if (clean1.length !== clean2.length) {\n    return false;\n  }\n  \n  const charCount = {};\n  \n  // Count characters in first string\n  for (let char of clean1) {\n    charCount[char] = (charCount[char] || 0) + 1;\n  }\n  \n  // Check against second string\n  for (let char of clean2) {\n    if (!charCount[char]) {\n      return false;\n    }\n    charCount[char]--;\n  }\n  \n  // All counts should be zero\n  return Object.values(charCount).every(count => count === 0);\n}\n```\n\n**Approach 4: Single pass with two frequency maps**\n```javascript\nfunction areAnagrams(str1, str2) {\n  const clean1 = str1.replace(/\\s+/g, '').toLowerCase();\n  const clean2 = str2.replace(/\\s+/g, '').toLowerCase();\n  \n  if (clean1.length !== clean2.length) {\n    return false;\n  }\n  \n  const freq1 = {};\n  const freq2 = {};\n  \n  // Count frequencies in both strings\n  for (let i = 0; i < clean1.length; i++) {\n    freq1[clean1[i]] = (freq1[clean1[i]] || 0) + 1;\n    freq2[clean2[i]] = (freq2[clean2[i]] || 0) + 1;\n  }\n  \n  // Compare frequency objects\n  for (let char in freq1) {\n    if (freq1[char] !== freq2[char]) {\n      return false;\n    }\n  }\n  \n  return true;\n}\n```\n\n**Approach 5: Using Array as frequency counter (for lowercase letters only)**\n```javascript\nfunction areAnagramsLettersOnly(str1, str2) {\n  const clean1 = str1.replace(/[^a-z]/gi, '').toLowerCase();\n  const clean2 = str2.replace(/[^a-z]/gi, '').toLowerCase();\n  \n  if (clean1.length !== clean2.length) {\n    return false;\n  }\n  \n  const freq = new Array(26).fill(0);\n  \n  // Count characters (a=0, b=1, ..., z=25)\n  for (let i = 0; i < clean1.length; i++) {\n    freq[clean1.charCodeAt(i) - 97]++;\n    freq[clean2.charCodeAt(i) - 97]--;\n  }\n  \n  // All frequencies should be zero\n  return freq.every(count => count === 0);\n}\n```\n\n**Group Anagrams Function:**\n```javascript\nfunction groupAnagrams(strs) {\n  const groups = new Map();\n  \n  for (let str of strs) {\n    // Use sorted string as key\n    const key = str.split('').sort().join('');\n    \n    if (!groups.has(key)) {\n      groups.set(key, []);\n    }\n    groups.get(key).push(str);\n  }\n  \n  return Array.from(groups.values());\n}\n\n// Usage\nconst words = ['eat', 'tea', 'tan', 'ate', 'nat', 'bat'];\nconsole.log(groupAnagrams(words));\n// [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n```\n\n**Advanced: Valid Anagram with Unicode support**\n```javascript\nfunction areAnagramsUnicode(str1, str2) {\n  // Normalize strings to handle unicode variations\n  const clean1 = str1.normalize().replace(/\\s+/g, '').toLowerCase();\n  const clean2 = str2.normalize().replace(/\\s+/g, '').toLowerCase();\n  \n  if (clean1.length !== clean2.length) {\n    return false;\n  }\n  \n  // Use Array.from to handle multi-byte characters correctly\n  const chars1 = Array.from(clean1).sort();\n  const chars2 = Array.from(clean2).sort();\n  \n  return chars1.join('') === chars2.join('');\n}\n```\n\n**Time Complexity:** O(n log n) for sorting approach, O(n) for frequency counting\n**Space Complexity:** O(n) for both approaches"
  },
  {
    "id": "pseudo-7",
    "question": "Write a program to swap two numbers without using a third variable",
    "answer": "**Problem:** Swap the values of two variables without using an additional temporary variable.\n\n**Method 1: Using Arithmetic Operations (Addition/Subtraction)**\n```javascript\nfunction swapNumbers(a, b) {\n  console.log(`Before swap: a = ${a}, b = ${b}`);\n  \n  a = a + b;  // a now contains sum of both\n  b = a - b;  // b now contains original value of a\n  a = a - b;  // a now contains original value of b\n  \n  console.log(`After swap: a = ${a}, b = ${b}`);\n  return { a, b };\n}\n\n// Usage\nswapNumbers(10, 20);\n// Before swap: a = 10, b = 20\n// After swap: a = 20, b = 10\n```\n\n**Method 2: Using Multiplication/Division**\n```javascript\nfunction swapNumbers(a, b) {\n  console.log(`Before swap: a = ${a}, b = ${b}`);\n  \n  a = a * b;  // a now contains product\n  b = a / b;  // b now contains original a\n  a = a / b;  // a now contains original b\n  \n  console.log(`After swap: a = ${a}, b = ${b}`);\n  return { a, b };\n}\n\n// Note: This method fails if either number is 0\n```\n\n**Method 3: Using XOR Bitwise Operation**\n```javascript\nfunction swapNumbers(a, b) {\n  console.log(`Before swap: a = ${a}, b = ${b}`);\n  \n  a = a ^ b;  // a now contains XOR of both\n  b = a ^ b;  // b now contains original a\n  a = a ^ b;  // a now contains original b\n  \n  console.log(`After swap: a = ${a}, b = ${b}`);\n  return { a, b };\n}\n\n// Works with integers only\nswapNumbers(15, 25);\n```\n\n**Method 4: Using ES6 Destructuring (Most Modern Approach)**\n```javascript\nfunction swapNumbers(a, b) {\n  console.log(`Before swap: a = ${a}, b = ${b}`);\n  \n  [a, b] = [b, a];  // Swap using destructuring\n  \n  console.log(`After swap: a = ${a}, b = ${b}`);\n  return { a, b };\n}\n\n// Clean and readable\nswapNumbers(100, 200);\n```\n\n**Method 5: Using Array Operations**\n```javascript\nfunction swapNumbers(a, b) {\n  console.log(`Before swap: a = ${a}, b = ${b}`);\n  \n  a = [b, b = a][0];  // Assigns b to a, and a to b\n  \n  console.log(`After swap: a = ${a}, b = ${b}`);\n  return { a, b };\n}\n```\n\n**Comparison of Methods:**\n\n| Method | Pros | Cons |\n|--------|------|------|\n| Addition/Subtraction | Works with all numbers | Risk of overflow |\n| Multiplication/Division | Mathematical approach | Fails with zero |\n| XOR | Efficient, no overflow | Integers only |\n| Destructuring | Clean, readable | Modern JS only |\n| Array | Creative approach | Less readable |\n\n**Time Complexity:** O(1) for all methods\n**Space Complexity:** O(1) for all methods"
  },
  {
    "id": "pseudo-8",
    "question": "Find the factorial of a number using recursion",
    "answer": "**Problem:** Calculate the factorial of a number using recursive approach.\n\n**Recursive Solution:**\n```javascript\nfunction factorial(n) {\n  // Base case\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n  \n  // Recursive case\n  return n * factorial(n - 1);\n}\n\n// Usage\nconsole.log(factorial(5)); // 120\nconsole.log(factorial(0)); // 1\nconsole.log(factorial(1)); // 1\nconsole.log(factorial(6)); // 720\n```\n\n**Enhanced Version with Input Validation:**\n```javascript\nfunction factorial(n) {\n  // Input validation\n  if (typeof n !== 'number') {\n    throw new TypeError('Input must be a number');\n  }\n  \n  if (n < 0) {\n    throw new Error('Factorial is not defined for negative numbers');\n  }\n  \n  if (!Number.isInteger(n)) {\n    throw new Error('Factorial is only defined for integers');\n  }\n  \n  // Base case\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n  \n  // Recursive case\n  return n * factorial(n - 1);\n}\n\n// Test cases\ntry {\n  console.log(factorial(5));   // 120\n  console.log(factorial(0));   // 1\n  console.log(factorial(-1));  // Error\n} catch (error) {\n  console.error(error.message);\n}\n```\n\n**Iterative Version for Comparison:**\n```javascript\nfunction factorialIterative(n) {\n  if (n < 0) return undefined;\n  if (n === 0 || n === 1) return 1;\n  \n  let result = 1;\n  for (let i = 2; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n\nconsole.log(factorialIterative(5)); // 120\n```\n\n**Memoized Recursive Version (Optimized):**\n```javascript\nconst factorialMemo = (() => {\n  const cache = {};\n  \n  return function factorial(n) {\n    if (n < 0) return undefined;\n    if (n === 0 || n === 1) return 1;\n    \n    if (cache[n]) {\n      return cache[n];\n    }\n    \n    cache[n] = n * factorial(n - 1);\n    return cache[n];\n  };\n})();\n\n// Test memoized version\nconsole.log(factorialMemo(10)); // 3628800\nconsole.log(factorialMemo(10)); // Cached result\n```\n\n**Tail Recursive Version:**\n```javascript\nfunction factorialTailRec(n, accumulator = 1) {\n  if (n === 0 || n === 1) {\n    return accumulator;\n  }\n  \n  return factorialTailRec(n - 1, n * accumulator);\n}\n\nconsole.log(factorialTailRec(5)); // 120\n```\n\n**Big Integer Version (for Large Numbers):**\n```javascript\nfunction factorialBigInt(n) {\n  if (n < 0n) return undefined;\n  if (n === 0n || n === 1n) return 1n;\n  \n  return n * factorialBigInt(n - 1n);\n}\n\nconsole.log(factorialBigInt(20n)); // 2432902008176640000n\n```\n\n**Visualization of Recursive Calls:**\n```javascript\nfunction factorialVis(n, depth = 0) {\n  const indent = '  '.repeat(depth);\n  console.log(`${indent}factorial(${n}) called`);\n  \n  if (n === 0 || n === 1) {\n    console.log(`${indent}Base case: returning 1`);\n    return 1;\n  }\n  \n  const result = n * factorialVis(n - 1, depth + 1);\n  console.log(`${indent}factorial(${n}) = ${n} * factorial(${n-1}) = ${result}`);\n  return result;\n}\n\nfactorialVis(4);\n// Shows the call stack visualization\n```\n\n**Time Complexity:** O(n)\n**Space Complexity:** O(n) due to recursive call stack\n\n**Key Points:**\n- Factorial of 0 is defined as 1\n- Factorial is only defined for non-negative integers\n- Recursive solution is elegant but uses more memory\n- For large numbers, consider iterative approach or memoization"
  },
  {
    "id": "pseudo-9",
    "question": "Write a program to check if a number is prime",
    "answer": "**Problem:** Determine if a given number is prime (divisible only by 1 and itself).\n\n**Basic Approach:**\n```javascript\nfunction isPrime(num) {\n  // Handle edge cases\n  if (num <= 1) return false;\n  if (num <= 3) return true;\n  if (num % 2 === 0 || num % 3 === 0) return false;\n  \n  // Check for divisors from 5 onwards\n  for (let i = 5; i * i <= num; i += 6) {\n    if (num % i === 0 || num % (i + 2) === 0) {\n      return false;\n    }\n  }\n  \n  return true;\n}\n\n// Usage\nconsole.log(isPrime(17)); // true\nconsole.log(isPrime(25)); // false\nconsole.log(isPrime(2));  // true\nconsole.log(isPrime(1));  // false\n```\n\n**Simple Approach (Less Optimized):**\n```javascript\nfunction isPrimeSimple(num) {\n  if (num <= 1) return false;\n  if (num === 2) return true;\n  if (num % 2 === 0) return false;\n  \n  // Check odd divisors up to square root\n  for (let i = 3; i <= Math.sqrt(num); i += 2) {\n    if (num % i === 0) {\n      return false;\n    }\n  }\n  \n  return true;\n}\n```\n\n**Trial Division Method:**\n```javascript\nfunction isPrimeTrial(num) {\n  if (num < 2) return false;\n  \n  // Check divisibility by all numbers from 2 to sqrt(num)\n  for (let i = 2; i <= Math.sqrt(num); i++) {\n    if (num % i === 0) {\n      return false;\n    }\n  }\n  \n  return true;\n}\n\n// Test with various numbers\nconst testNumbers = [2, 3, 4, 5, 17, 25, 29, 97, 100];\ntestNumbers.forEach(num => {\n  console.log(`${num} is ${isPrimeTrial(num) ? 'prime' : 'not prime'}`);\n});\n```\n\n**Optimized Version with Early Returns:**\n```javascript\nfunction isPrimeOptimized(num) {\n  // Handle small numbers\n  if (num < 2) return false;\n  if (num === 2) return true;\n  if (num % 2 === 0) return false;\n  if (num < 9) return true;\n  if (num % 3 === 0) return false;\n  \n  // Check for divisors of the form 6k ± 1\n  const limit = Math.floor(Math.sqrt(num));\n  for (let i = 5; i <= limit; i += 6) {\n    if (num % i === 0 || num % (i + 2) === 0) {\n      return false;\n    }\n  }\n  \n  return true;\n}\n```\n\n**Prime Check with Factorization Info:**\n```javascript\nfunction primeCheck(num) {\n  if (num <= 1) {\n    return { isPrime: false, factors: [], reason: 'Number must be greater than 1' };\n  }\n  \n  if (num === 2) {\n    return { isPrime: true, factors: [1, 2], reason: '2 is the only even prime' };\n  }\n  \n  if (num % 2 === 0) {\n    return { isPrime: false, factors: [1, 2, num/2, num], reason: 'Even number > 2' };\n  }\n  \n  // Find factors\n  const factors = [1];\n  for (let i = 3; i <= Math.sqrt(num); i += 2) {\n    if (num % i === 0) {\n      factors.push(i);\n      if (i !== num / i) {\n        factors.push(num / i);\n      }\n    }\n  }\n  factors.push(num);\n  factors.sort((a, b) => a - b);\n  \n  const isPrime = factors.length === 2;\n  return {\n    isPrime,\n    factors,\n    reason: isPrime ? 'Only divisible by 1 and itself' : `Has ${factors.length} factors`\n  };\n}\n\n// Usage\nconsole.log(primeCheck(17)); // { isPrime: true, factors: [1, 17], ... }\nconsole.log(primeCheck(15)); // { isPrime: false, factors: [1, 3, 5, 15], ... }\n```\n\n**Generate Prime Numbers up to N:**\n```javascript\nfunction generatePrimes(n) {\n  const primes = [];\n  \n  for (let i = 2; i <= n; i++) {\n    if (isPrime(i)) {\n      primes.push(i);\n    }\n  }\n  \n  return primes;\n}\n\nconsole.log(generatePrimes(30)); // [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n```\n\n**Sieve of Eratosthenes (for multiple primes):**\n```javascript\nfunction sieveOfEratosthenes(n) {\n  const isPrime = new Array(n + 1).fill(true);\n  isPrime[0] = isPrime[1] = false;\n  \n  for (let i = 2; i * i <= n; i++) {\n    if (isPrime[i]) {\n      for (let j = i * i; j <= n; j += i) {\n        isPrime[j] = false;\n      }\n    }\n  }\n  \n  return isPrime.map((prime, index) => prime ? index : null)\n                .filter(index => index !== null);\n}\n\nconsole.log(sieveOfEratosthenes(30)); // [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n```\n\n**Performance Comparison:**\n```javascript\nfunction comparePrimeMethods(num) {\n  const methods = [\n    { name: 'Basic', fn: isPrimeSimple },\n    { name: 'Optimized', fn: isPrimeOptimized },\n    { name: 'Trial Division', fn: isPrimeTrial }\n  ];\n  \n  methods.forEach(method => {\n    const start = performance.now();\n    const result = method.fn(num);\n    const end = performance.now();\n    \n    console.log(`${method.name}: ${result} (${(end - start).toFixed(4)}ms)`);\n  });\n}\n\n// Compare performance\ncomparePrimeMethods(982451653); // Large prime number\n```\n\n**Time Complexity:** O(√n)\n**Space Complexity:** O(1)\n\n**Key Optimizations:**\n- Check divisibility by 2 and 3 first\n- Only check numbers of form 6k ± 1\n- Only check up to √n\n- Handle edge cases early"
  },
  {
    "id": "pseudo-10",
    "question": "Generate Fibonacci series up to n terms",
    "answer": "**Problem:** Generate the first n terms of the Fibonacci sequence where each number is the sum of the two preceding ones.\n\n**Method 1: Iterative Approach (Most Efficient)**\n```javascript\nfunction fibonacciSeries(n) {\n  if (n <= 0) return [];\n  if (n === 1) return [0];\n  if (n === 2) return [0, 1];\n  \n  const series = [0, 1];\n  \n  for (let i = 2; i < n; i++) {\n    series[i] = series[i - 1] + series[i - 2];\n  }\n  \n  return series;\n}\n\n// Usage\nconsole.log(fibonacciSeries(10)); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\nconsole.log(fibonacciSeries(5));  // [0, 1, 1, 2, 3]\n```\n\n**Method 2: Recursive Approach (Less Efficient)**\n```javascript\nfunction fibonacciRecursive(n) {\n  if (n <= 0) return 0;\n  if (n === 1) return 1;\n  \n  return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2);\n}\n\nfunction fibonacciSeriesRecursive(n) {\n  const series = [];\n  for (let i = 0; i < n; i++) {\n    series.push(fibonacciRecursive(i));\n  }\n  return series;\n}\n\nconsole.log(fibonacciSeriesRecursive(8)); // [0, 1, 1, 2, 3, 5, 8, 13]\n```\n\n**Method 3: Memoized Recursive (Optimized)**\n```javascript\nconst fibonacciMemo = (() => {\n  const cache = { 0: 0, 1: 1 };\n  \n  return function fibonacci(n) {\n    if (n in cache) {\n      return cache[n];\n    }\n    \n    cache[n] = fibonacci(n - 1) + fibonacci(n - 2);\n    return cache[n];\n  };\n})();\n\nfunction fibonacciSeriesMemo(n) {\n  const series = [];\n  for (let i = 0; i < n; i++) {\n    series.push(fibonacciMemo(i));\n  }\n  return series;\n}\n\nconsole.log(fibonacciSeriesMemo(15));\n```\n\n**Method 4: Using Generator Function**\n```javascript\nfunction* fibonacciGenerator(n) {\n  let a = 0, b = 1, count = 0;\n  \n  while (count < n) {\n    if (count === 0) {\n      yield a;\n    } else if (count === 1) {\n      yield b;\n    } else {\n      const next = a + b;\n      yield next;\n      a = b;\n      b = next;\n    }\n    count++;\n  }\n}\n\n// Usage\nconst fibGen = fibonacciGenerator(10);\nconst series = [...fibGen];\nconsole.log(series); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n```\n\n**Method 5: Space-Optimized Version**\n```javascript\nfunction fibonacciOptimized(n) {\n  if (n <= 0) return [];\n  if (n === 1) return [0];\n  if (n === 2) return [0, 1];\n  \n  const series = [0, 1];\n  let prev = 0, curr = 1;\n  \n  for (let i = 2; i < n; i++) {\n    const next = prev + curr;\n    series.push(next);\n    prev = curr;\n    curr = next;\n  }\n  \n  return series;\n}\n\nconsole.log(fibonacciOptimized(12));\n```\n\n**Method 6: Using Array Destructuring**\n```javascript\nfunction fibonacciDestructuring(n) {\n  if (n <= 0) return [];\n  if (n === 1) return [0];\n  \n  const series = [0, 1];\n  let [a, b] = [0, 1];\n  \n  for (let i = 2; i < n; i++) {\n    [a, b] = [b, a + b];\n    series.push(b);\n  }\n  \n  return series;\n}\n\nconsole.log(fibonacciDestructuring(8));\n```\n\n**Method 7: Using Binet's Formula (Mathematical)**\n```javascript\nfunction fibonacciBinet(n) {\n  const phi = (1 + Math.sqrt(5)) / 2;\n  const psi = (1 - Math.sqrt(5)) / 2;\n  \n  return Math.round((Math.pow(phi, n) - Math.pow(psi, n)) / Math.sqrt(5));\n}\n\nfunction fibonacciSeriesBinet(n) {\n  const series = [];\n  for (let i = 0; i < n; i++) {\n    series.push(fibonacciBinet(i));\n  }\n  return series;\n}\n\n// Note: May have floating point precision issues for large numbers\nconsole.log(fibonacciSeriesBinet(10));\n```\n\n**Method 8: Using Matrix Exponentiation (Advanced)**\n```javascript\nfunction matrixMultiply(a, b) {\n  return [\n    [a[0][0] * b[0][0] + a[0][1] * b[1][0], a[0][0] * b[0][1] + a[0][1] * b[1][1]],\n    [a[1][0] * b[0][0] + a[1][1] * b[1][0], a[1][0] * b[0][1] + a[1][1] * b[1][1]]\n  ];\n}\n\nfunction matrixPower(matrix, n) {\n  if (n === 1) return matrix;\n  if (n % 2 === 0) {\n    const half = matrixPower(matrix, n / 2);\n    return matrixMultiply(half, half);\n  }\n  return matrixMultiply(matrix, matrixPower(matrix, n - 1));\n}\n\nfunction fibonacciMatrix(n) {\n  if (n === 0) return 0;\n  if (n === 1) return 1;\n  \n  const baseMatrix = [[1, 1], [1, 0]];\n  const result = matrixPower(baseMatrix, n);\n  return result[0][1];\n}\n\nfunction fibonacciSeriesMatrix(n) {\n  const series = [];\n  for (let i = 0; i < n; i++) {\n    series.push(fibonacciMatrix(i));\n  }\n  return series;\n}\n```\n\n**Performance Comparison:**\n```javascript\nfunction compareFibonacciMethods(n) {\n  const methods = [\n    { name: 'Iterative', fn: fibonacciSeries },\n    { name: 'Recursive', fn: fibonacciSeriesRecursive },\n    { name: 'Memoized', fn: fibonacciSeriesMemo },\n    { name: 'Optimized', fn: fibonacciOptimized }\n  ];\n  \n  methods.forEach(method => {\n    const start = performance.now();\n    const result = method.fn(n);\n    const end = performance.now();\n    \n    console.log(`${method.name}: ${(end - start).toFixed(4)}ms`);\n    console.log(`Result: [${result.slice(0, 5).join(', ')}${result.length > 5 ? ', ...' : ''}]`);\n  });\n}\n\n// Compare performance (be careful with recursive for large n)\ncompareFibonacciMethods(20);\n```\n\n**Time Complexity:**\n- Iterative: O(n)\n- Recursive: O(2^n)\n- Memoized: O(n)\n- Matrix: O(log n)\n\n**Space Complexity:**\n- Iterative: O(n)\n- Recursive: O(n) call stack\n- Memoized: O(n)\n\n**Recommended:** Use the iterative approach for best performance and readability."
  }
]
